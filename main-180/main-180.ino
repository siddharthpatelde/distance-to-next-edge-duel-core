/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
////////////////////////[   distnace to TWO edges using lidar sensor   ]////////////////////////////
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Author:Siddharth A. Patel
  Date: 24.05.2025

  Github: https://github.com/siddharthpatelde
  
  goal:           goal of this code is to optimise 
                  the logic of previuse distane 
                  to the next edge code.
                  because distnace generated by that code was very slow

  previuse_code:  https://github.com/siddharthpatelde/distance-to-next-edge 
                  (main > final_AllLidar_main)
                  
  new code:       -optemised logic, for faster output
                  -finding the distnace to TWO edges (left and right edges)
                  -therefor now sensor will cover area coverd by 180Â° of arc
                  -code will output TWO distnace (distnace to next edge from left edge and right edge)

  current_code:   https://github.com/siddharthpatelde/distance-to-next-edge-optemised
*/

#include <ArduinoJson.h>
#include <RPLidar.h>

RPLidar lidar;

#define RPLIDAR_MOTOR 3 // The PWM pin for control the speed of RPLIDAR's motor.

int point_count_left = 0;
int point_count_right = 0;

int new_scan_flag = 0; // defining flag variable to show if it is new scan or not i.e 1 --> new scan start, 0 --> not a new scan

/*definig valid distnace cound varibale to store the one number that represents 
how many valid distnaces we get from "get_distance_to_next_edge" function, so that we can use this number 
later as a size of array to perform distanec filteretion*/

int valid_distance_count_left = 0;
int valid_distance_count_right = 0;

float distance = 0;
float angle = 0;


#define scan_height 22 //in cm

/*
define the tolerance for edge detecation logic.
i.e when distnace comming from sensor is "k" times bigger than the one we
calculated from theory (triangle theory), then we say that we have edge detection at that angle
here "k""is our tolerance factor.
*/

#define tolerance_low 1.2  // 20% increse in theoretical value


/*
i have definded tolerance factors, so that i can ignore some values after first edge detection
*/


#include <ArduinoJson.h> //to use json string as output

JsonDocument doc1; //defining the jason object on top #1 for string that prints distnace
JsonDocument doc2; //defining the jason object on top #2 for string that prints total number of objects in previus scan and flag status

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//////////////////////////////////////////////////////[   core 0    ]///////////////////////////////////////////////////////// 
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



void setup(){ 
  //for the PICO to print the stuff in serial monitor
  Serial.begin(115200);

  // bind the RPLIDAR driver to the arduino hardware serial
  Serial1.begin(115200);  // For RPLidar
  lidar.begin(Serial1);

  // set pin modes
  pinMode(RPLIDAR_MOTOR, OUTPUT);

}
  
void loop(){
  if (IS_OK(lidar.waitPoint())) {

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //              data retrieval
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /* 
    here we take the data from lidar like, distances in cm, 
    angles in mm and a flat value for if its new scan or not
    */ 
    
    new_scan_flag = lidar.getCurrentPoint().startBit;     // 0 or 1
    distance = lidar.getCurrentPoint().distance;          // in mm 
    angle = lidar.getCurrentPoint().angle;                // in Degree


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //              data filtering 
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /*
    here i write logic to find all the positive distnaces and 
    counting how many valid angles, distnaces value are we getting 
    in one scan
    */

    if (new_scan_flag) {
      valid_distance_count_left = point_count_left;
      valid_distance_count_right = point_count_right;
      
      point_count_left = 0;
      point_count_right = 0;

      // doc2["new scan flag"] = new_scan_flag;
      // doc2["left count"] = valid_distance_count_left;
      // doc2["right count"] = valid_distance_count_right;
      
      // serializeJson(doc2, Serial);
      // Serial.println(); // Print newline for readability
    }

      //if(distance > 0 && angle > 90 && angle < 180){
      if(distance > 0 && angle > 0 && angle < 90){

      float distance_from_edge_right = get_distance_to_next_edge_right(angle,distance);
      
        if (distance_from_edge_right != 0) {

          if (point_count_right == valid_distance_count_right) {
          doc1["distance_right"] = distance_from_edge_right;
          }

          //doc1["distance id"] = point_count;
          point_count_right++;

          serializeJson(doc1, Serial);
          Serial.println(); // Print newline for readability
        }
      }  
      
      if(distance > 0 && angle > 90 && angle < 180){

        float distance_from_edge_left = get_distance_to_next_edge_left(angle,distance);

        if (distance_from_edge_left != 0) {

          if (point_count_left == 0) {
          doc1["distance_left"] = distance_from_edge_left;
          }

          //doc1["distance id"] = point_count;
          point_count_left++;

          serializeJson(doc1, Serial);
          Serial.println(); // Print newline for readability
        }
      }


  }else {
    analogWrite(RPLIDAR_MOTOR, 0); //stop the rplidar motor
    
    // try to detect RPLIDAR... 
    rplidar_response_device_info_t info;
    if (IS_OK(lidar.getDeviceInfo(info, 100))) {
       //detected...
       lidar.startScan();
       analogWrite(RPLIDAR_MOTOR, 180); //150 pwm value of 5.5Hz case
       delay(1000);
    }
  }

}



float get_distance_to_next_edge_right(float angle_degrees, float distance_mm) {   //defined a function for left edge [0 ; 90]

    float distance_cm = distance_mm / 10;                 // Convert distance in mm to cm  
    float angle_radianse = (-(angle_degrees - 90) * PI) / 180;    // Concert angles in degrees to radianse, and applying quadrant calculations

    float distance_calculated = scan_height / cos(angle_radianse);


    if(distance_cm > distance_calculated * tolerance_low){
      float distance_to_next_edge_right = tan(angle_radianse) * scan_height;
        return distance_to_next_edge_right; // Print newline for readability
    }
}



float get_distance_to_next_edge_left(float angle_degrees, float distance_mm) {   //defined a function for left edge [90 ; 180]

    float distance_cm = distance_mm / 10;                 // Convert distance in mm to cm  
    float angle_radianse = ((angle_degrees - 90) * PI) / 180;    // Concert angles in degrees to radianse, and applying quadrant calculations

    float distance_calculated = scan_height / cos(angle_radianse);


    if(distance_cm > distance_calculated * tolerance_low){
      float distance_to_next_edge_left = tan(angle_radianse) * scan_height;
        return distance_to_next_edge_left; // Print newline for readability
    }
}






